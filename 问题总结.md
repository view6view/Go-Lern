# defer

go语言中的`defer`可以将指定的语句延迟执行，用于实现资源的回收。

## 规则一：在函数退出时执行

需要注意，`defer`后的语句是在函数退出时执行，而不是类似C++中RAII那样离开块作用域执行。
下面的代码最终输出`hello world`。

```go
package main

import "fmt"

func main() {
	if true {
		defer fmt.Println("world")
	}

	fmt.Printf("hello ")
}
```

## 规则二：当defer被声明时，其参数就会被实时解析

下面的代码最终输出`0`，因为`n`作为参数传入的时候就已经被解析了。

```go
package main

import "fmt"

func main() {
	n := 0
	defer fmt.Println(n)
	n++
}
```

## 规则三：defer执行顺序为先进后出

多条`defer`语句就会进行压栈，先声明的先执行。
下面的代码输出`3 2 1 0`。

```go
package main

import "fmt"

func main() {
	for i := 0; i < 4; i++ {
		defer fmt.Println(i)
	}
}
```

# string

- 可以直接指定下标获取字符串指定位置字符

```go
func test(s string)  {
	for i := 0; i < len(s); i++ {
		fmt.Println(s[i])
	}
}
```

# 测试

Go 语言推荐测试文件和源代码文件放在一块，测试文件以 `_test.go` 结尾。比如，当前 package 有 `calc.go` 一个文件，我们想测试 `calc.go` 中的 `Add` 和 `Mul` 函数，那么应该新建 `calc_test.go` 作为测试文件。

```
example/
   |--calc.go
   |--calc_test.go
```

假如 `calc.go` 的代码如下：

```go
package main

func Add(a int, b int) int {
    return a + b
}

func Mul(a int, b int) int {
    return a * b
}
```

那么 `calc_test.go` 中的测试用例可以这么写：

```go
package main

import "testing"

func TestAdd(t *testing.T) {
	if ans := Add(1, 2); ans != 3 {
		t.Errorf("1 + 2 expected be 3, but %d got", ans)
	}

	if ans := Add(-10, -20); ans != -30 {
		t.Errorf("-10 + -20 expected be -30, but %d got", ans)
	}
}
```

- 测试用例名称一般命名为 `Test` 加上待测试的方法名。
- 测试用的参数有且只有一个，在这里是 `t *testing.T`。
- 基准测试(benchmark)的参数是 `*testing.B`，TestMain 的参数是 `*testing.M` 类型。

运行 `go test`，该 package 下所有的测试用例都会被执行。

```
$ go test
ok      example 0.009s
```

或 `go test -v`，`-v` 参数会显示每个用例的测试结果，另外 `-cover` 参数可以查看覆盖率。

```sh
$ go test -v
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
=== RUN   TestMul
--- PASS: TestMul (0.00s)
PASS
ok      example 0.007s
```

如果只想运行其中的一个用例，例如 `TestAdd`，可以用 `-run` 参数指定，该参数支持通配符 `*`，和部分正则表达式，例如 `^`、`$`。

```sh
$ go test -run TestAdd -v
=== RUN   TestAdd
--- PASS: TestAdd (0.00s)
PASS
ok      example 0.007s
```
